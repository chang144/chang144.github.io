(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{282:function(a,e,t){"use strict";t.r(e);var s=t(14),n=Object(s.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"使用docker-以及docker-compose部署go程序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用docker-以及docker-compose部署go程序"}},[a._v("#")]),a._v(" 使用Docker 以及Docker Compose部署Go程序")]),a._v(" "),e("h2",{attrs:{id:"为什么需要docker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要docker"}},[a._v("#")]),a._v(" 为什么需要docker")]),a._v(" "),e("blockquote",[e("p",[a._v("使用docker的主要目标是其容器化。可以为应用程序提供一致的环境，而不依赖它运行的主机")])]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"部署示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#部署示例"}},[a._v("#")]),a._v(" 部署示例")]),a._v(" "),e("h4",{attrs:{id:"_1-准备代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-准备代码"}},[a._v("#")]),a._v(" 1.准备代码")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('package main\n\nimport (\n\t"fmt"\n\t"net/http"\n)\n\nfunc main() {\n\thttp.HandleFunc("/", hello)\n\tserver := &http.Server{\n\t\tAddr: ":8888",\n\t}\n  fmt.Println("server startup...")\n\tif err := server.ListenAndServe(); err != nil {\n\t\tfmt.Printf("server startup failed, err:%v\\n", err)\n\t}\n}\n\nfunc hello(w http.ResponseWriter, _ *http.Request) {\n\tw.Write([]byte("hello liwenzhou.com!"))\n}\n')])])]),e("p",[a._v("这里是简单代码")]),a._v(" "),e("h4",{attrs:{id:"_2-创建docker镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-创建docker镜像"}},[a._v("#")]),a._v(" 2.创建Docker镜像")]),a._v(" "),e("blockquote",[e("p",[a._v("镜像(image)包含运行应用程序所需的所有东西——代码/二进制文件、运行时、依赖项以及所需的任何其它人间系统对象")])]),a._v(" "),e("p",[a._v("简单讲，镜像是定义应用程序以及运行所需的一切")]),a._v(" "),e("h4",{attrs:{id:"_3-编写dockerfile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-编写dockerfile"}},[a._v("#")]),a._v(" 3.编写Dockerfile")]),a._v(" "),e("p",[a._v("要创建Docker镜像(image)必须在配置文件中的指定步骤，这个文件默认称为"),e("code",[a._v("Dockerfile")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('FROM golang:alpine\n\n# 为我们的镜像设置必要的环境变量\nENV GO111MODULE=on \\\n    CGO_ENABLED=0 \\\n    GOOS=linux \\\n    GOARCH=amd64\n\n# 移动到工作目录：/build\nWORKDIR /build\n\n# 将代码复制到容器中\nCOPY . .\n\n# 将我们的代码编译成二进制可执行文件app\nRUN go build -o app .\n\n# 移动到用于存放生成的二进制文件的 /dist 目录\nWORKDIR /dist\n\n# 将二进制文件从 /build 目录复制到这里\nRUN cp /build/app .\n\n# 声明服务端口\nEXPOSE 8888\n\n# 启动容器时运行的命令\nCMD ["/dist/app"]\n')])])]),e("h4",{attrs:{id:"_4-dockerfile解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-dockerfile解析"}},[a._v("#")]),a._v(" 4.Dockerfile解析")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("From")])])]),a._v(" "),e("p",[a._v("使用了基础镜像 "),e("code",[a._v("golang:alpine")]),a._v("来创建镜像。这个镜像运行的是alpine Linux发行版，该发行版的大小很小并内置了Go。有大量公开可用的Docker镜像，请查看https://hub.docker.com/_/golang")]),a._v(" "),e("ul",[e("li",[a._v("Env")])]),a._v(" "),e("p",[a._v("用来设置编译阶段需要的环境变量")]),a._v(" "),e("ul",[e("li",[a._v("WORKDIR,COPY,RUN")]),a._v(" "),e("li",[a._v("EXPORT,CMD")])]),a._v(" "),e("p",[a._v("声明服务端口，应用程序监听这个端口并通过这个端口对外提供服务。还定义了运行镜像执行的默认执行命令"),e("code",[a._v('CMD ["/dist/app"]')])]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"构建镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建镜像"}},[a._v("#")]),a._v(" 构建镜像")]),a._v(" "),e("p",[a._v("在项目目录下面，在终端输入下面的命令创建镜像，并指定镜像名称为"),e("code",[a._v("go_app")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker build . -t go_app\n")])])]),e("p",[a._v("等待构建结束，输出 "),e("code",[a._v("Successfully")])]),a._v(" "),e("p",[a._v("等输出 "),e("code",[a._v("Successfully")]),a._v("后，此时镜像已经准备好了，但是目前什么项目都没有，需要运行下面的代码来运行镜像。注："),e("strong",[a._v("运行中的镜像称为镜像")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker run -p 8888:8888 go_app\n")])])]),e("p",[a._v("标志位"),e("code",[a._v("-p")]),a._v("来定义端口绑定，由于容器中的应用程序在端口8888上运行，这里绑定的主机端口也是8888。如果要绑定另一个端口，则可以使用 "),e("code",[a._v("-p $HOST_PORT:8888")])]),a._v(" "),e("p",[a._v("到这里就可以测试我们的程序是否工作正常，打开 http://127.0.0.1:8888 查看事先定义的响应内容。")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"分阶段构建示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分阶段构建示例"}},[a._v("#")]),a._v(" 分阶段构建示例")]),a._v(" "),e("p",[a._v("Go程序编译之后可得到一个可执行的二进制文件，在最终的镜像中不需要go编译器，也就是说我们只需要一个运行最终二进制文件的容器即可。")]),a._v(" "),e("p",[a._v("Docker的最佳实践之一是通过仅保留二进制文件来减小镜像大小，为此，我们将使用一种称为多阶段构建的技术")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('FROM golang:alpine AS builder\n\n# 为我们的镜像设置必要的环境变量\nENV GO111MODULE=on \\\n    CGO_ENABLED=0 \\\n    GOOS=linux \\\n    GOARCH=amd64\n\n# 移动到工作目录：/build\nWORKDIR /build\n\n# 将代码复制到容器中\nCOPY . .\n\n# 将我们的代码编译成二进制可执行文件 app\nRUN go build -o app .\n\n###################\n# 接下来创建一个小镜像\n###################\nFROM scratch\n\n# 从builder镜像中把/dist/app 拷贝到当前目录\nCOPY --from=builder /build/app /\n\n# 需要运行的命令\nENTRYPOINT ["/app"]\n')])])]),e("p",[a._v("使用这种技术，我们剥离了使用"),e("code",[a._v("golang:alpine")]),a._v("作为编译镜像来编译得到二进制可执行文件的过程，并基于"),e("code",[a._v("scratch")]),a._v("生成一个简单的、非常小的新镜像。我们将二进制文件从命名为"),e("code",[a._v("builder")]),a._v("的第一个镜像中复制到新创建的"),e("code",[a._v("scratch")]),a._v("镜像中。有关scratch镜像的更多信息，请查看https://hub.docker.com/_/scratch")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"附带其他文件的部署示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#附带其他文件的部署示例"}},[a._v("#")]),a._v(" 附带其他文件的部署示例")]),a._v(" "),e("p",[a._v("web项目(前后端不分离)一般会有静态文件或者配置文件，需要拷贝到最终的镜像文件中")]),a._v(" "),e("p",[a._v("例如 "),e("code",[a._v("templates")]),a._v(" | "),e("code",[a._v("static")]),a._v(" | "),e("code",[a._v("conf")]),a._v(" 三个文件的内容拷贝到镜像文件中")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('FROM golang:alpine AS builder\n\n# 为我们的镜像设置必要的环境变量\nENV GO111MODULE=on \\\n    CGO_ENABLED=0 \\\n    GOOS=linux \\\n    GOARCH=amd64\n\n# 移动到工作目录：/build\nWORKDIR /build\n\n# 复制项目中的 go.mod 和 go.sum文件并下载依赖信息\nCOPY go.mod .\nCOPY go.sum .\nRUN go mod download\n\n# 将代码复制到容器中\nCOPY . .\n\n# 将我们的代码编译成二进制可执行文件 bubble\nRUN go build -o bubble .\n\n###################\n# 接下来创建一个小镜像\n###################\nFROM scratch\n\nCOPY ./templates /templates\nCOPY ./static /static\nCOPY ./conf /conf\n\n# 从builder镜像中把/dist/app 拷贝到当前目录\nCOPY --from=builder /build/bubble /\n\n# 需要运行的命令\nENTRYPOINT ["/bubble", "conf/config.ini"]\n')])])]),e("p",[e("strong",[a._v("Tips：")]),a._v(" 这里把COPY静态文件的步骤放在上层，把COPY二进制可执行文件放在下层，争取多使用缓存。")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"关联其他容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关联其他容器"}},[a._v("#")]),a._v(" 关联其他容器")]),a._v(" "),e("p",[a._v("项目中使用了MySQL，可以选择使用如下命令启动一个MySQL容器，它的别名为"),e("code",[a._v("mysql8019")]),a._v("；root用户的密码为"),e("code",[a._v("root1234")]),a._v("；挂载容器中的"),e("code",[a._v("/var/lib/mysql")]),a._v("到本地的"),e("code",[a._v("/Users/docker/mysql")]),a._v("目录；内部服务端口为3306，映射到外部的13306端口。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker run --name mysql8019 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root1234 -v /Users/q1mi/docker/mysql:/var/lib/mysql -d mysql:8.0.19\n")])])]),e("p",[a._v("这里需要修改一下我们程序中配置的MySQL的host地址为容器别名，使它们在内部通过别名（此处为mysql8019）联通。")]),a._v(" "),e("div",{staticClass:"language-ini extra-class"},[e("pre",{pre:!0,attrs:{class:"language-ini"}},[e("code",[e("span",{pre:!0,attrs:{class:"token section"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),e("span",{pre:!0,attrs:{class:"token section-name selector"}},[a._v("mysql")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")])]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("user")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("root")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("password")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("root1234")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("host")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("mysql8019")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("port")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("3306")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("db")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("bubble")]),a._v("\n")])])]),e("p",[a._v("修改后记得重新构建"),e("code",[a._v("bubble_app")]),a._v("镜像：")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[a._v("docker")]),a._v(" build "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v(".")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-t")]),a._v(" bubble_app\n")])])]),e("p",[a._v("我们这里运行"),e("code",[a._v("bubble_app")]),a._v("容器的时候需要使用"),e("code",[a._v("--link")]),a._v("的方式与上面的"),e("code",[a._v("mysql8019")]),a._v("容器关联起来，具体命令如下：")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[a._v("docker")]),a._v(" run "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--link")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("mysql8019:mysql8019 "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-p")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("8888")]),a._v(":8888 bubble_app\n")])])]),e("hr"),a._v(" "),e("h3",{attrs:{id:"docker-compose模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose模式"}},[a._v("#")]),a._v(" Docker Compose模式")]),a._v(" "),e("p",[a._v("除了像上面一样使用"),e("code",[a._v("--link")]),a._v("的方式来关联两个容器之外，我们还可以使用"),e("code",[a._v("Docker Compose")]),a._v("来定义和运行多个容器。")]),a._v(" "),e("p",[e("code",[a._v("Compose")]),a._v("是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，你可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。")]),a._v(" "),e("p",[a._v("使用Compose基本上是一个三步过程：")]),a._v(" "),e("ol",[e("li",[a._v("使用"),e("code",[a._v("Dockerfile")]),a._v("定义你的应用环境以便可以在任何地方复制。")]),a._v(" "),e("li",[a._v("定义组成应用程序的服务，"),e("code",[a._v("docker-compose.yml")]),a._v(" 以便它们可以在隔离的环境中一起运行。")]),a._v(" "),e("li",[a._v("执行 "),e("code",[a._v("docker-compose up")]),a._v("命令来启动并运行整个应用程序。")])]),a._v(" "),e("p",[a._v("我们的项目需要两个容器分别运行"),e("code",[a._v("mysql")]),a._v("和"),e("code",[a._v("bubble_app")]),a._v("，我们编写的"),e("code",[a._v("docker-compose.yml")]),a._v("文件内容如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('# yaml 配置\nversion: "3.7"\nservices:\n  mysql8019:\n    image: "mysql:8.0.19"\n    ports:\n      - "33061:3306"\n    command: "--default-authentication-plugin=mysql_native_password --init-file /data/application/init.sql"\n    environment:\n      MYSQL_ROOT_PASSWORD: "root1234"\n      MYSQL_DATABASE: "bubble"\n      MYSQL_PASSWORD: "root1234"\n    volumes:\n      - ./init.sql:/data/application/init.sql\n  bubble_app:\n    build: .\n    command: sh -c "./wait-for.sh mysql8019:3306 -- ./bubble ./conf/config.ini"\n    depends_on:\n      - mysql8019\n    ports:\n      - "8888:8888"\n')])])]),e("p",[a._v("这个 Compose 文件定义了两个服务："),e("code",[a._v("bubble_app")]),a._v(" 和 "),e("code",[a._v("mysql8019")]),a._v("。其中：")]),a._v(" "),e("h5",{attrs:{id:"bubble-app"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bubble-app"}},[a._v("#")]),a._v(" bubble_app")]),a._v(" "),e("p",[a._v("使用当前目录下的"),e("code",[a._v("Dockerfile")]),a._v("文件构建镜像，并通过"),e("code",[a._v("depends_on")]),a._v("指定依赖"),e("code",[a._v("mysql8019")]),a._v("服务，声明服务端口8888并绑定对外8888端口。")]),a._v(" "),e("h5",{attrs:{id:"mysql8019"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql8019"}},[a._v("#")]),a._v(" mysql8019")]),a._v(" "),e("p",[a._v("mysql8019 服务使用 Docker Hub 的公共 mysql:8.0.19 镜像，内部端口3306，外部端口33061。")]),a._v(" "),e("p",[a._v("这里需要注意一个问题就是，我们的"),e("code",[a._v("bubble_app")]),a._v("容器需要等待"),e("code",[a._v("mysql8019")]),a._v("容器正常启动之后再尝试启动，因为我们的web程序在启动的时候会初始化MySQL连接。这里共有两个地方要更改，第一个就是我们"),e("code",[a._v("Dockerfile")]),a._v("中要把最后一句注释掉：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('# Dockerfile\n...\n# 需要运行的命令（注释掉这一句，因为需要等MySQL启动之后再启动我们的Web程序）\n# ENTRYPOINT ["/bubble", "conf/config.ini"]\n')])])]),e("p",[a._v("第二个地方是在"),e("code",[a._v("bubble_app")]),a._v("下面添加如下命令，使用提前编写的"),e("code",[a._v("wait-for.sh")]),a._v("脚本检测"),e("code",[a._v("mysql8019:3306")]),a._v("正常后再执行后续启动Web应用程序的命令：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('command: sh -c "./wait-for.sh mysql8019:3306 -- ./bubble ./conf/config.ini"\n')])])]),e("p",[a._v("当然，因为我们现在要在"),e("code",[a._v("bubble_app")]),a._v("镜像中执行sh命令，所以不能在使用"),e("code",[a._v("scratch")]),a._v("镜像构建了，这里改为使用"),e("code",[a._v("debian:stretch-slim")]),a._v("，同时还要安装"),e("code",[a._v("wait-for.sh")]),a._v("脚本用到的"),e("code",[a._v("netcat")]),a._v("，最后不要忘了把"),e("code",[a._v("wait-for.sh")]),a._v("脚本文件COPY到最终的镜像中，并赋予可执行权限哦。更新后的"),e("code",[a._v("Dockerfile")]),a._v("内容如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('FROM golang:alpine AS builder\n\n# 为我们的镜像设置必要的环境变量\nENV GO111MODULE=on \\\n    CGO_ENABLED=0 \\\n    GOOS=linux \\\n    GOARCH=amd64\n\n# 移动到工作目录：/build\nWORKDIR /build\n\n# 复制项目中的 go.mod 和 go.sum文件并下载依赖信息\nCOPY go.mod .\nCOPY go.sum .\nRUN go mod download\n\n# 将代码复制到容器中\nCOPY . .\n\n# 将我们的代码编译成二进制可执行文件 bubble\nRUN go build -o bubble .\n\n###################\n# 接下来创建一个小镜像\n###################\nFROM debian:stretch-slim\n\nCOPY ./wait-for.sh /\nCOPY ./templates /templates\nCOPY ./static /static\nCOPY ./conf /conf\n\n\n# 从builder镜像中把/dist/app 拷贝到当前目录\nCOPY --from=builder /build/bubble /\n\nRUN set -eux; \\\n\tapt-get update; \\\n\tapt-get install -y \\\n\t\t--no-install-recommends \\\n\t\tnetcat; \\\n        chmod 755 wait-for.sh\n\n# 需要运行的命令\n# ENTRYPOINT ["/bubble", "conf/config.ini"]\n')])])]),e("p",[a._v("所有的条件都准备就绪后，就可以执行下面的命令跑起来了：")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[a._v("docker-compose")]),a._v(" up\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);