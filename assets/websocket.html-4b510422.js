import{_ as e,o,c,e as t}from"./app-f1c34f66.js";const d={},a=t(`<h1 id="_3-5-websocket" tabindex="-1"><a class="header-anchor" href="#_3-5-websocket" aria-hidden="true">#</a> 3.5 - WebSocket</h1><p>解决场景之一：服务器主动发送消息给客户端</p><h2 id="http轮询" tabindex="-1"><a class="header-anchor" href="#http轮询" aria-hidden="true">#</a> HTTP轮询</h2><ul><li><p>问题产生：怎样才能在用户不做任何操作的情况下，网页能收到消息并发送变更？</p></li><li><p>解决方案：网页不断定时发HTTP请求到服务器，服务器收到请求后给客户端响应消息</p></li></ul><p>这一解决方案是一种<strong>伪</strong>服务器推送的形式</p><h2 id="长轮询" tabindex="-1"><a class="header-anchor" href="#长轮询" aria-hidden="true">#</a> 长轮询</h2><p>将HTTP的请求超时设置很大，期间如果服务器接收到了请求，返回响应，如果超时，则再次发起新的HTTP请求</p><p>这样就可以减少HTTP的请求个数</p><h2 id="什么是websocket" tabindex="-1"><a class="header-anchor" href="#什么是websocket" aria-hidden="true">#</a> 什么是WebSocket</h2><p>在tcp连接的两端，在同一时间内，双方都可以主动向对方推送数据，这叫做<strong>全双工</strong></p><blockquote><p><code>HTTP/1.1</code>属于<strong>半双工</strong>，也是基于TCP协议，同一时间内，客户端和服务器只能有一方主动发送数据</p></blockquote><p>由于<code>HTTP/1.1</code>的半双工属性，在需要全双工的场景下，催生出了基于TCP的新协议<strong>WebSocket</strong></p><blockquote><p>WebSocket作用于应用层，同时注意，<code>WebSocket</code>与<code>socket</code>之间接近毫无关系</p></blockquote><h2 id="如何建立websocket连接" tabindex="-1"><a class="header-anchor" href="#如何建立websocket连接" aria-hidden="true">#</a> 如何建立WebSocket连接</h2><p>为了兼容一些使用场景，浏览器在<strong>TCP三次握手</strong>建立连接之后，都统一使用<strong>HTTP协议</strong>进行一次通信</p><p>想要<strong>建立WebSocket连接</strong>，在原来的HTTP协议之上，加入一些特殊的<code>header</code>头</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Connection: Upgrade
Upgrade: WebSocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些header头的意思是：</p><ul><li><code>Connection: Upgrade</code>:表示浏览器想要升级协议</li><li><code>Upgrade: WebSocket</code>:升级的协议是WebSocket</li><li><code>Sec-WebSocket-Key</code>:随机生成的base64码</li></ul><p>此时，如果服务器支持升级为WebSocket协议，将会走WebSocket握手流程，返回<code>101</code>状态码的响应给浏览器</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>HTTP/1.1 101 Switching Protocols\\r\\n
Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\\r\\n
Upgrade: WebSocket\\r\\n
Connection: Upgrade\\r\\n
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="websocket升级过程中的base64码" tabindex="-1"><a class="header-anchor" href="#websocket升级过程中的base64码" aria-hidden="true">#</a> WebSocket升级过程中的base64码</h3><p>在HTTP升级为WebSocket过程中，请求和响应中分别携带的<code>Sec-WebSocket-Key</code>和<code>Sec-WebSocket-Accept</code>用以验证WebSocket升级是否成功</p><ol><li>浏览器随机生成base64码放到<code>Sec-WebSocket-Key</code>中，发送到服务器</li><li>服务器根据客户端（浏览器）生成的base64码，用某一种<strong>公开</strong>的算法编程另一段<strong>字符串</strong>，放到HTTP响应的<code>Sec-WebSocket-Accept</code>头中</li><li>浏览器根据<strong>该公开的算法</strong>（与服务器一致的算法）将base64码转成另一段字符串，并与服务器返回的<code>Sec-WebSocket-Accept</code>进行对比，如果一致，则验证通过</li></ol><p>到这里，经历<strong>两次HTTP握手</strong>，WebSocket就建立完成。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f4edd3018914fe6eb38fad6aa3fd2d65.png" alt="websocket建立连接"></p><blockquote><p>WebSocket是基于TCP协议，在经历三次TCP握手之后，利用HTTP协议升级为WebSocket协议</p><p>WebSocket协议只有在建立连接的过程中使用到了HTTP</p></blockquote><h2 id="websocket的消息格式" tabindex="-1"><a class="header-anchor" href="#websocket的消息格式" aria-hidden="true">#</a> WebSocket的消息格式</h2><p>建立完成WebSocket之后，两端就使用WebSocket的数据格式进行通信</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3a63a86e5d7e72a37b9828fc6e65c21f.png" alt="websocket数据格式"></p><p>关注一下字段：</p><ul><li><p><code>opcode</code>:用来标志这个数据帧是什么类型</p><ul><li>opcode = 1，指text类型（string）的数据包</li><li>opcode = 2，指二进制数据格式（[]byte)的数据报</li><li>opcode = 8，关闭连接信号</li></ul></li><li><p><code>payload length</code>:存放传输的数据的长度，单位是字节</p><p>存放payload长度的字段有好几个，我们可以使用前面的<code>7bit</code>，也可以使用后面的<code>7+16bit</code>或者<code>7+64bit</code></p><p>websocket不管数据有多大，都会读取<code>7bit</code>，根据它的取值在决定要不要在读取<code>+16bit</code>或者<code>+64bit</code></p><ul><li>开始的<code>7bit</code>的值在<code>0~125</code>，那么表示<strong>payload的全部长度</strong>，读取最开始的<code>7bit</code>就够了</li><li>如果是<code>126(0x7E)</code>，表示payload的长度范围在<code>126~65535</code>,接下来只需再读<code>+16bit</code></li><li>如果是<code>127(0x7F)</code>，表示payload的长度范围在<code>&gt;=65535</code>,接下来只需再读<code>+64bit</code></li></ul></li><li><p><code>payload data</code>:存放实际传输的数据</p></li></ul><blockquote><p>因为TCP协议本身是全双工，而WebSocket是直接使用TCP去传输数据，所以会出现<strong>粘包</strong>的问题（？）</p></blockquote><p>WebSocket一般会使用<strong>消息头+消息体</strong>的格式去重新包装要发送的数据</p><h2 id="websocket的使用场" tabindex="-1"><a class="header-anchor" href="#websocket的使用场" aria-hidden="true">#</a> WebSocket的使用场</h2><p>适用于服务器和客户端频繁交互的大部分场景</p>`,36),i=[a];function n(s,r){return o(),c("div",null,i)}const b=e(d,[["render",n],["__file","websocket.html.vue"]]);export{b as default};
