# redis 

**一文Redis**学习自：

> [图解Redis介绍 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/redis/)
>
> [一文读懂Redis - 简书 (jianshu.com)](https://www.jianshu.com/p/0a1c9fc23c01)

## redis简介

Redis是c语言开发的一个开源高性能键值对的内存数据库，可以用来作数据库、缓存、消息中间件等场景，是一个NoSQL（非关系型数据库）的数据库

## redis特点

+ 优秀的性能，数据储存在内存中，读写速度非常快，可以支持并发10W QPS
+ 单线程但是进程，是线程安全的，采用IO多路复用
+ 可作为分布式锁
+ 支持5种数据类型
+ 支持数据持久化到磁盘
+ 可以作为消息中间件使用，支持消息发布以及订阅

## 数据类型

| 类型                   | 简介                                                    | 特性                                                         | 场景                                       |
| ---------------------- | ------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| string                 | 二进制安全                                              | 可以包含任何数据                                             | ...                                        |
| Hash（字典）           | 键值对集合，即map                                       | 适合存储对象                                                 | 存储，读取，修改用户属性                   |
| List（列表）           | 链表（双向链表）                                        | 增删快，提供了操作某一元素的api                              | 最新消息排行，消息队列                     |
| set（集合）            | hash实现，元素不重复                                    | 添加，删除，查找的复杂度都是O(1)，提供了求交集，并集，差集的操作 | 共同好友；利用唯一性，统计访问网站的所有Ip |
| sorted set（有序集合） | 将set种的元素增加一个权重参数score，元素按score有序排列 | 数据插入集合时，已经进行了天然排序                           | 排行耪，带权重的消息队列                   |

## 缓存

数据缓存是Redis最重要的一个场景，为缓存而生

> 在`springboot`中，一般为两种使用方式：
>
> + 直接通过`RedisTemplate` 使用
> + 通过`Spring Cache`集成Redis

## 缓存遇到的问题

### 1.数据一致性

在分布式环境下，缓存和数据库很容易出现数据一致性问题，如果项目对缓存的要求是**强一致性**，那就不使用缓存

只能在项目中使用策略降低缓存与数据库一致性的概率，是无法保障两者的强一致性，一般策略包括缓存更新机制，更新数据库后及时更新缓存、缓存失败时增加重试机制

### 2.缓存雪崩

#### a. 什么是缓存雪崩？

当某一时刻出现大规模的缓存失效，此时如果有大量的请求（这些请求量超过了数据库的承载量）发生，导致数据库压力巨大，在高并发的情况下，可能瞬间导致数据库宕机，重启数据库后又有新的大量的请求，马上将数据库打死。这个就是缓存雪崩

> [什么是缓存雪崩、缓存击穿、缓存穿透？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/346651831)

#### b. 产生原因：造成雪崩的关键在于同一时间大规模的key失效

+ redis宕机
+ 采用了相同的过期时间

#### c. 解决方案

1. 事故前：redis高可用方案，主从+哨兵，集群方案，提高redis的容灾性，避免全盘崩溃
2. 事故中：较少数据库压力，本地Ehcache缓存+限流及降级，避免超过数据库承受压力
3. 事故后：做redis持久化，一旦redis重启，可以从磁盘中快速恢复数据
4. 在原有的失效时间上加上一个随机值，避免因为采用相同的过期时间导致的缓存雪崩

### 3.缓存穿透

#### a. 什么是缓存穿透？

指缓存和数据库中都没有的数据，用户（黑客）不断发起请求，导致请求直接查询数据库，用恶意的请求攻击数据库可能直接导致数据库和缓存挂掉。这个就是缓存穿透。

#### b. 解决方案

1. 在请求接口层增加校验，比如：用户签名，参数校验，不合法的请求直接return
2. 针对有效id做认证或者直接拦截，不符合的id直接过滤或者采用统一的key保存到redis，下次不合法的id请求时，直接到缓存中获取数据
3. 采用redis的高级接口Bloom Filter（布隆过滤器），利用高效的数据结构和算法快速判断出这个key是否在数据库中存在，不存在则直接return，存在查询DB刷新KV再return

### 4.缓存击穿

#### a. 什么是缓存击穿？

缓存击穿是针对一点（通常是一个热点的key）导致redis异常。但是这个key是非常热点，；有大并发及中国的请求对其进行访问，当这个key失效时，大量的并发请求全部打在数据库上，导致数据库压力剧增。这种现象叫做缓存击穿

### b.产生原因：某个热点的key失效，大量并发集中打到数据库上

+ 热点key过期
+ 数据库上的请求数量过多

#### c. 解决方案

1. 数据基本不变：热点数据value基本不更新，可以设置为永不过期
2. 数据更新不频繁：缓存刷新流程耗时较少时，可以采用redis、zookeeper等分布式中间件的分布式互斥锁或者本地互斥锁保证少量的请求能请求到数据库并重新更新缓存，其他的流程等锁释放后才可以访问新的缓存
3. 数据更新频繁：采用定时线程，再缓存过期主动重新构建缓存或延长过期时间，保证所有的请求能一种访问缓存

## 为什么redis会这么快

redis可以到达10W+ QPS，而redis是单进程单线程的模型，完全基于内存的操作，CPU不是redis的瓶颈，redis的瓶颈是内存以及网络带宽

+ 使用类似HashMap的原理，HashMap的查询以及操作的时间复杂度是O(1)，且绝大数请求是纯粹的内存操作，数据保存在内存中
+ 数据结构简单，对数据操作简单，基于KV
+ 死锁现象采用单线程操作，避免了不必要的上下文切换以及竞争条件，不存在CPU切换现象，也不存在考虑各种锁的问题
+ 使用非阻塞IO，多路复用IO模型

## redis淘汰策略

+ `volatile`前缀的策略都是从已过期的数据集中进行淘汰
+ `allkeys`前缀的策略都是面向所有key进行淘汰
+ LRU（least recently used）最近很少用到
+ LFU（least frequently used）最不常用
+ 它们的触发条件都是redis使用的内存达到阙值时

| 名称            | 描述                                                     |
| --------------- | -------------------------------------------------------- |
| volatile-lru    | 从`已设置过期时间`的数据集中挑选`最近最少使用`的数据淘汰 |
| volatile-lfu    | 从`已设置过期时间`的数据集中挑选`最不经常使用`的数据淘汰 |
| volatile-ttl    | 从`已设置过期时间`的数据集中挑选`将要过期`的数据淘汰     |
| volatile-random | 从`已设置过期时间`的数据集中挑选`任意数据`淘汰           |
| allkeys-lru     | 当`内存不足`写入新数据时淘汰`最近最少使用`的key          |
| allkeys-random  | 当`内存不足`写入新数据时淘汰`随机选择`的key              |
| allkeys-lfu     | 当`内存不足`写入新数据时淘汰`最不经常使用`的key          |
| no-eviction     | 当`内存不足`写入新数据时，写入操作会报错，同时不删除数据 |

## redis持久化

redis持久化策略有两种：

+ RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略
+ AOF：把所有的对redis的服务器进行修改的命令都存在以恶搞文件里，命令的集合

> redis默认是快照RDB的持久化方式

### 数据库备份和灾难恢复：

定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度快

## redis主从复制

+ 从节点执行`slaveof[masterIP][masterPort]`，保存主节点信息
+ 从节点中的定时任务发现主节点信息，建立和主节点的socket连接
+ 从节点发送Ping信号，主节点返回Pong，两边能互相通信
+ 连接节点后，主节点将所有数据发送到从节点（数据同步）
+ 主节点把当前的数据同步给从节点，便完成了复杂的建立过程。主节点会持续把写满了发送给从节点，保证主从数据一致性

### a. 主从复制存在问题

+ 一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预
+ 主节点的**写**能力受到单机的限制
+ 主节点的**存储**能力受到单机的限制
+ 如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或者秒级别的卡顿

## redis哨兵模式

+ **监控**：不断检查主服务器和从服务器是否正常运行
+ **通知**：当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他应用程序发出通知
+ **自动故障转移**：当主节点不能正常工作时，Sentinel 会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了
+ **配置提供者**：在 Redis Sentinel 模式下，客户端应用在初始化时连接的是 Sentinel 节点集合，从中获取主节点的信息